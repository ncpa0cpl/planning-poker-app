import type { BunFile, Server } from "bun";
import type { CacheConfig } from "./headers/generate-cache-control-header";
import { generateCacheControlHeader } from "./headers/generate-cache-control-header";
import type { MaybePromise } from "./http-server";
import { RouterResponse } from "./router-response";

type ResponseData = {
  body: any;
  status: number;
  statusText: string;
};

const copyHeaders = (from: Headers, to: Headers) => {
  for (const [name, value] of from.entries()) {
    to.set(name, value);
  }
};

export class Context {
  public static createResponse(
    ctx: Context,
  ): MaybePromise<RouterResponse | undefined> {
    if (ctx.dontSendResponse) {
      return;
    }

    let response: Promise<RouterResponse>;

    if (ctx.responseData instanceof RouterResponse) {
      copyHeaders(ctx.responseHeaders, ctx.responseData.headers);
      response = Promise.resolve(ctx.responseData);
    } else {
      response = RouterResponse.from(
        ctx.responseData.body,
        {
          headers: ctx.responseHeaders,
          status: ctx.responseData.status,
          statusText: ctx.responseData.statusText,
        },
      );
    }

    const logs = Object.entries(ctx.logData);
    if (ctx.sendType || logs.length > 0) {
      return response.then(r => {
        for (let i = 0; i < logs.length; i++) {
          const [key, value] = logs[i]!;
          r.setLogData(key, value);
        }
        if (ctx.sendType) {
          r.setLogData("responded_with", ctx.sendType);
        }
        return r;
      });
    }

    return response;
  }

  private sendType?: string;
  private logData: Record<string, string> = {};
  private responseData: ResponseData | RouterResponse = {
    body: "Not Found",
    status: 404,
    statusText: "Not Found",
  };
  private responseHeaders: Headers = new Headers();
  private dontSendResponse = false;

  public constructor(
    public readonly request: Request,
    public readonly bunServer: Server,
    public readonly url: URL,
    public readonly params: Record<string, string>,
    public readonly wildcardValue: null | string,
  ) {
  }

  public getJsonBody<T>(): Promise<T> {
    return this.request.json();
  }

  public getParam(name: string): string | undefined {
    return this.params[name];
  }

  public getQParam(name: string): string | null {
    return this.url.searchParams.get(name);
  }

  public getAllQParams(name: string): string[] {
    return this.url.searchParams.getAll(name);
  }

  public getPathWildcard(): string | null {
    return this.wildcardValue;
  }

  public send(response: RouterResponse): Context {
    this.responseData = response;
    this.sendType = "response";
    return this;
  }

  public sendJson(code: number, data: any): Context {
    this.responseHeaders.set("Content-Type", "application/json");
    this.responseData = {
      body: JSON.stringify(data),
      status: code,
      statusText: "OK",
    };
    this.sendType = "json";
    return this;
  }

  public sendHtml(code: number, data: string): Context {
    this.responseHeaders.set("Content-Type", "text/html");
    this.responseData = {
      body: data,
      status: code,
      statusText: "OK",
    };
    this.sendType = "html";
    return this;
  }

  public sendText(code: number, data: string): Context {
    this.responseHeaders.set("Content-Type", "text/plain");
    this.responseData = {
      body: data,
      status: code,
      statusText: "OK",
    };
    this.sendType = "text";
    return this;
  }

  public sendFile(
    code: number,
    data: Uint8Array | Blob | ReadableStream | BunFile,
  ): Context {
    this.responseHeaders.delete("Content-Type");
    this.responseData = {
      body: data,
      status: code,
      statusText: "OK",
    };
    this.sendType = "file";
    return this;
  }

  public noResponse(): Context {
    this.dontSendResponse = true;
    return this;
  }

  public redirect(code: number, url: string): Context {
    this.responseHeaders.set("Location", url);
    this.responseData = {
      body: "",
      status: code,
      statusText: "OK",
    };
    this.sendType = undefined;
    return this;
  }

  public setHeader(name: string, value: string): Context {
    this.responseHeaders.set(name, value);
    return this;
  }

  public setCacheControl(options: CacheConfig): Context {
    this.setHeader("Cache-Control", generateCacheControlHeader(options));
    return this;
  }

  /**
   * Adds a key-value pair to the log entry of the response
   * generated by this context.
   */
  public logValue(key: string, value: string): Context {
    this.logData[key] = value;
    return this;
  }
}
